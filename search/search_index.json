{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":""},{"location":"#a-collection-of-general-pretrained-networks-for-cellular-cryoet","title":"A collection of general pretrained networks for cellular cryoET","text":"<p>Trained on a large and curated body of cryoET datasets, easymode provides pretrained networks for feature detection in cellular cryoET. Our models are hosted via Hugging Face and automatically distributed for inference \u2013 meaning you don't need to worry about downloading model weights.</p> <p>Simply call <code>easymode segment ribosome</code>, point to your data, and easymode will do the rest. Or <code>microtubule</code>. Or <code>mitochondrion</code>. Or <code>npc</code>. Or <code>tric</code>. Or check out the full model library.</p>"},{"location":"#easymode-ecosystem","title":"easymode ecosystem","text":"<p>easymode was built on top of Ais, inspired by Membrain, and designed for use within Warp/Relion/M pipelines. By growing the easymode model library, our eventual goal is to enable Pom's tricks - context-aware particle picking, area selective template matching, and representing datasets as searchable databases - without requiring any training at all.</p>"},{"location":"models/","title":"easymode model library","text":"<p>This sections lists the features for which pretrained easymode models are currently available. We have split them up into two categories: \ud83d\udc26 species and \ud83c\udfde\ufe0f biomes. The distinction is purely descriptive.</p> <p>The \ud83d\udc26species include ribosomes, microtubules, vaults, and other well-defined macromolecular assemblies that you might consider averaging. They are what M also calls species. </p> <p>The \ud83c\udfde\ufe0f biomes category covers organelles and other cellular environments, such as mitochondria, the nuclear envelope, and the cytoplasm, as well as auxiliary classes such as 'void' (i.e. non-sample areas, non-vitreous ice, etc.). These models can be used to sample the context within which the species are embedded; or in other words, the biomes are where the species live.</p> <p>You can always run <code>easymode list</code> to see the most up-to-date list of available models.</p>"},{"location":"models/#model-readiness-classification","title":"Model readiness classification","text":"<p>We classify the readiness of each model for routine use into three categories. </p> <ol> <li>Models marked with \ud83d\udfe2 are available for general use and have been validated in some way via subtomogram averaging. </li> <li>Models marked with \ud83d\udd35 are available, and while we personally trust the networks work well, validation by subtomogram averaging is not 100% complete. For example, the npc (nuclear pore complex) model is online and seems accurate, but we aren't happy with the subtomogram averaging resolution we achieved in validation yet (40 \u00c5 - mostly a matter of STA processing). </li> <li>Models marked with \ud83d\udea7 are a work in progress; some are already online, but validation by STA hasn't progressed very far yet (mostly for a lack of time) and we can't promise great results.  </li> </ol>"},{"location":"models/actin/","title":"","text":"<p><code>easymode segment actin</code></p> <p>The actin model was trained to output a cylindrical tube with a diameter of 60 \u00c5 along actin filaments. It was one of the most challenging models to train thus far and remains somewhat experimental.</p> <p>In combination with the <code>--filament</code> flag in <code>easymode pick</code>, the model enables tracing actin filaments and picking of particles at regular intervals along individual filaments, with an accurate prior on the particle orientation and class labels linking particles to the parent filaments (_aisFilamentID). Use the <code>--per-filament</code> flag to write .star files for individual actin filaments. </p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment actin</code> output overlaid on a tomogram from training dataset 001_HELA. We have yet to validate the model on unseen data (by subtomogram averaging)</p>"},{"location":"models/cytoplasm/","title":"","text":"<p><code>easymode segment cytoplasm</code></p> <p>The cytoplasm model was trained at 30 \u00c5/px and has a receptive field of almost 5000 \u00c5. At this scale it processes tomograms of up to 768 x 768 x 384 nm in one go, usually within a few seconds.  </p> <p>Input tomograms should still be 10.0 \u00c5/px; downsampling is performed automatically.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment cytoplasm</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model.</p>"},{"location":"models/cytoplasmic_granule/","title":"","text":"<p><code>easymode segment cytoplasmic_granule</code></p> <p>This model segments cytoplasmic granules - relatively dense, roughly spherical bodies found in the cytoplasm of many species, including human cells.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment cytoplasmic_granule</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model. Some slight erroneous activation can be seen on the cytoplasmic granules - these are currently being trained out.   </p>"},{"location":"models/ferritin/","title":"\ud83d\udea7 Ferritin","text":"<p>\ud83d\udea7</p>"},{"location":"models/hsp60/","title":"Hsp60","text":"<p>\ud83d\udea7</p>"},{"location":"models/microtubule/","title":"","text":"<p><code>easymode segment microtubule</code></p> <p>The microtubule model was trained to output a cylindrical tube with a diameter of 180 \u00c5 along microtubules, approximately annotating the lumen of microtubules only. As a result, closely adjacent microtubules are still segmented as individual filaments.</p> <p>In combination with the <code>--filament</code> flag in <code>easymode pick</code>, the model enables tracing individual microtubules and picking particles at regular intervals along individual filaments, with an accurate prior on the particle orientation and class labels linking particles to the parent filaments (_aisFilamentID). Use the <code>--per-filament</code> flag to write .star files for individual microtubules. This allows subtomogram averaging of individual filaments. </p> <p>For validation, we segmented, picked, and averaged microtubules in a large dataset of FIB-milled HeLa cell tomograms. After using per-filament averaging to determine polarity and protofilament count, then subboxing individual protofilaments, we achieved a 4.6 \u00c5 overall resolution (49k particles). </p> <p></p> <p>Note</p> <p>At 4.6 \u00c5 resolution, differences between alpha and beta tubulin are still almost impossible to see. We didn't bother trying to sort out the seam during the averaging process.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment microtuble</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model.</p>"},{"location":"models/mitochondrial_granule/","title":"\ud83d\udfe2 Mitochondrial granule","text":"<p><code>easymode segment mitochondrial_granule</code></p> <p>This model segments mitochondrial granules - the relatively dense, the rough and dense granules found in mitochondria of many species.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment mitochondrial_granule</code> output overlaid on a tomogram of small section of a human (HeLa) cell.   </p>"},{"location":"models/mitochondrion/","title":"","text":"<p><code>easymode segment mitochondrion</code></p> <p>The mitochondrion model was trained at 30 \u00c5/px and has a receptive field of almost 5000 \u00c5. As a result, it is mostly able to recognize the full extent of mitochondria, and at high magnifications can be applied to tomograms in one go - no sliding window required, and thus utilizing the global context of the tomogram. The model was trained on manually curated 2D Ais UNet generated pseudolabels, using training data from human, mouse, baker's yeast, fission yeast, chlamydomonas, dictyostelium discoideum, and a number of eukaryotic species, as well as on various prokaryotic species to include counterexamples to mitochondria. We expect the model to perform well on any other FIB-milled cultured cell type, but note that mitochondria can have very different morphologies in different tissue samples; for example in human sperm (also included in the training data) - and advise caution in such cases.</p> <p>Validation by subtomogram averaging of mitochondrial complexes - using the mitochondrion model to masks picks of ribosomes and various mitochondrial complexes - is planned.</p> <p>Input tomograms should still be 10.0 \u00c5/px; downsampling is performed automatically.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment mitochondrion</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model.</p>"},{"location":"models/npc/","title":"","text":"<p><code>easymode segment npc</code></p> <p>Unlike most species models, the npc (nuclear pore complex) model operates at 20 \u00c5/px, resulting in ~8x faster inference. Downsampling is performed automatically, so input tomograms still should be the default 10 \u00c5/px. As in most other cases, we used a 2D Ais UNet to generate pseudo-labels for training the easymode 3D UNet.</p> <p>Nuclear pore complexes aren't very rare but occur at low copy numbers. We used dataset EMPIAR-11845, consisting of 152 tomograms of FIB-milled D. discoideum cells, for validation of model by subtomogram averaging. This dataset was acquired with a relatively large pixel size and most tomograms contain part of the nuclear envelope, so the data offered a sufficient number of NPC instances for averaging. Some of the tomograms in this dataset were also included in the training data for this model, so there is a degree of contamination between training and validation in this case; we will repeat validation on a separate dataset later. </p> <p></p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment npc</code> output overlaid on a tomogram from EMPIAR-11845 (FIB-milled D. discoideum).</p>"},{"location":"models/nuclear_envelope/","title":"","text":"<p><code>easymode segment nuclear_envelope</code></p> <p>The nuclear envelope model was trained at 30 \u00c5/px and has a receptive field of almost 5000 \u00c5. At this scale it processes tomograms of up to 768 x 768 x 384 nm in one go, usually within a few seconds.</p> <p>Input tomograms should still be 10.0 \u00c5/px; downsampling is performed automatically. </p> <p></p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment nuclear_envelope</code> output overlaid on a tomogram from EMPIAR-11845 (FIB-milled D. discoideum) - note that while this dataset was included in the training collection, the tomogram was not.</p>"},{"location":"models/nucleus/","title":"\ud83d\udea7 Nucleus","text":"<p>\ud83d\udea7</p>"},{"location":"models/prohibitin/","title":"\ud83d\udea7 Prohibitin","text":"<p>\ud83d\udea7</p>"},{"location":"models/ribosome/","title":"","text":"<p><code>easymode segment ribosome</code></p> <p>The ribosome model is a shape-based ribosome segmentation model and was trained on manually selected 3D subtomograms that were labelled using a 2D Ais UNet + post-processing. It was trained at the default easymode pixel size of 10 \u00c5/px on training data samples from bacteria as well as eukaryotes. And one archaeon.</p> <p>Validation so far shows that the model supports picking and subtomogram averaging to high resolution in S. cerevisiae (3.4 \u00c5, 95k particles), C. reinhardtii (4.4 \u00c5, 59k particles) and H. sapiens (6.4 \u00c5, 30k particles). </p> <p> </p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment ribosome</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model. Some slight erroneous activation can be seen on the cytoplasmic granules - these are currently being trained out.   </p>"},{"location":"models/tric/","title":"","text":"<p><code>easymode segment tric</code></p> <p>The tric (T-complex protein Ring Complex) model was trained to output 170 \u00c5 spheres in the position of TRiC complexes. As in most other cases, the training labels were generated with an Ais 2D UNet applied to manually selected 3D subtomograms with a high degree of test-time augmentation. After generating these pseudo-labels we corrected for the missing wedge artefacts that 2D UNets introduce by picking particles &amp; drawing new spherical labels at their positions.</p> <p>Validation is ongoing.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment tric</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model.</p>"},{"location":"models/vault/","title":"","text":"<p><code>easymode segment vault</code></p> <p>The vault model was trained on manually curated 3D subtomograms that were labelled by a 2D Ais UNet. The Ais net output a shape-based segmentation of vaults; as a result, the 3D easymode network also outputs vault shape, although with strong missing wedge artefacts. This does not really matter for picking.</p> <p>For initial validation we used dataset EMPIAR-11845, consisting of 152 tomograms of FIB-milled D. discoideum cells. Because this dataset was also a part of the training dataset, there is some contamination between training and validation; we will repeat the validation later with a different dataset. The reason for running validation on this set was that few datasets contain enough vault particles for annotation and averaging.</p> <p>Vaults remain rare even in this dataset; we found on average between 2 to 3 particles per tomogram, or 348 in total. With D39 symmetry, subtomogram averaging plateaued at a resolution of 13.6 \u00c5. The very cap of the vault, where the D39 symmetry breaks (see L\u00f6vestam and Scheres, Structure, 2025), was excluded from the mask.</p> <p></p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment vault</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model. </p>"},{"location":"models/void/","title":"","text":"<p><code>easymode segment void</code></p> <p>Void refers to regions of tomograms that are outside the sample (e.g. above or below the lamella), contain poor-quality data (e.g. thick or poorly reconstructed areas), or are dominated by artefacts (e.g. dense ice contamination). One application of segmenting void is to measure or approximate the distance from a particle to the edges of a lamella; sampling the void segmentation output at the location of picked particles offers a practical way of estimating this distance. </p> <p>A second use of the void model is to approximate the quality of entire tomograms, as demonstrated in this preprint. Simply running <code>easymode segment void</code> on all tomograms in a dataset, tabulating the average void output value for each tomogram, and sorting low to high is a practical way to filter good from worse tomograms.</p> <p>The model is relatively fast, as it works at 20 \u00c5/px; but input is still expected to be at 10 \u00c5/px and is automatically downsampled.</p> <p>Example output </p> <p>      Video failed to load.    </p> <p>Example of <code>easymode segment void</code> output overlaid on a tomogram from EMPIAR-11899 (FIB-milled D. discoideum), a dataset which was not used to train this model. </p>"},{"location":"user_guide/overview/","title":"","text":"<p>Here you'll find installation and usage instructions.</p>"},{"location":"user_guide/examples/microtubule/","title":"Microtubule","text":""},{"location":"user_guide/examples/microtubule/#example-2-hela-microtubule","title":"Example 2: HeLa microtubule","text":"<p>In this example we used Warp, AreTomo3, easymode, Relion5, and M to reconstruct, denoise, segment, pick, and average microtubules in HeLa cells</p> Dataset and computational resources <p>For this test we used 621 tilt series of FIB-milled HeLa cells which we collected ourselves. They are not yet available online but hopefully will be soon. We used 4 NVIDIA RTX 4090 GPUs for most processing steps.</p> <p>At the onset the data in this example consisted of just tilt series and mdocs (we did not use the gain references). Pixel size was 1.56 \u00c5/px, dose 4.6 e-/\u00c5\u00b2 per tilt (150 e-/A\u00b2 total), dose-symmetric tilt series of \u00b145\u00b0 with 3\u00b0 increments. <pre><code>project_root/\n\u251c\u2500\u2500 frames/        # 621 x 31 =  19282 .tif files\n\u2502   \u251c\u2500\u2500 250531_l1p1_001_-10.0_20250531_093402.tif\n\u2502   \u251c\u2500\u2500 250531_l1p1_001_-7.0_20250531_093438.tif\n\u2502   \u2514\u2500\u2500 ... \n\u2514\u2500\u2500 mdocs/         # 621 .mdoc files\n    \u251c\u2500\u2500 250531_l1p1.mdoc\n    \u251c\u2500\u2500 250531_l1p1_2.mdoc\n    \u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"user_guide/examples/microtubule/#step-1-tomogram-reconstruction","title":"Step 1: tomogram reconstruction","text":"<p><pre><code>easymode reconstruct --frames frames --mdocs mdocs --apix 1.56 --dose 4.6 --no_halfmaps\n</code></pre> We now have 621 reconstructed tomograms at 10.00 \u00c5/px in <code>warp_tiltseries/reconstruction/</code>.</p>"},{"location":"user_guide/examples/microtubule/#step-2-tomogram-denoising","title":"Step 2: tomogram denoising","text":"<p><pre><code>easymode denoise --data warp_tiltseries/reconstruction --output warp_tiltseries/reconstruction/denoised --mode direct --method n2n --gpu 0,1,2,3\n</code></pre> This produced 621 denoised tomograms in <code>warp_tiltseries/reconstruction/denoised/</code>.</p>"},{"location":"user_guide/examples/microtubule/#step-3-microtubule-segmentation","title":"Step 3: microtubule segmentation","text":"<p><pre><code>easymode segment microtubule --data warp_tiltseries/reconstruction/denoised --output segmented --gpu 0,1,2,3\n</code></pre> Subtomogram averaging (STA) of microtubules is a bit more involved than averaging ribosomes. First, the number of protofilaments within a single microtubule is variable, and can change along its length. Second, microtubules are polar filaments, but the polarity is difficult to identify prior to performing any averaging; averaging microtubule segments without a strong prior on the orientation tpyically results in an average of mixed polarity, which precludes achieving high resolution. We therefore performed per-filament STA first, before assigning polarity to and pooling all 13-protofilament particles for global averaging. The first step is to pick particles on a per-filament basis.    </p>"},{"location":"user_guide/examples/microtubule/#step-4-vectorizing-microtubule-instances-generating-coordinates","title":"Step 4: vectorizing microtubule instances &amp; generating coordinates","text":"<p><pre><code>easymode pick microtubule --data segmented --output vectors/microtubule --length 1000 --spacing 200 --per_filament\n</code></pre> This created 699 star files, one per detected microtubule, listing coordinates with priors on the particle orientation based on the tangent to the filament. We then ran 250 separate WarpTools particle extraction and Relion5 Refine3D jobs for the 250 longest microtubules, and inspected the resulting averages to identify the number of protofilaments and polarity (relative to the reference 60 \u00c5 low-passed microtubule map) of each microtubule. This was a bit painful.</p> <p>We then pooled all particles found in filaments that clearly had 13 protofilaments and a consistent polarity (rotating the angles by 180 degrees for those particles that were inverted relative to the reference). This yielded ~3800 particles, which were roughly aligned. We exported these at 5 \u00c5/px using WarpTools ts_export_particles, ran a Relion5 Refine3D job which quickly reached ~10 \u00c5 resolution.</p> <p>Finally, we used ChimeraX and the 10 \u00c5 average to position 13 cropped alpha beta tubulin monomers in the map, sampled the translation and orientation of each monomer relative to the center of the full map, applied the resulting transformation matrices to the .star file (generating 13 new particles for each original 1 particle), and ran refinement in M. This reached 4.6 \u00c5.</p> <p></p> <p>Note</p> <p>It should be possible, even relatively straightforward, to average all particles at once rather than doing per-filament subtomogram averaging first. For instance, running a single Relion5 Refine3D job with 30\u00b0 of freedom around the prior gives a well aligned mixed-polarity average. Next, a 3D classification with 2 classes works well to separate the two polarities (especially when enforcing a C13 symmetry - which is not good for final averaging, but does help to accentuate the polarity in the microtubule cross-sections). Finally, correcting for the opposing polarities and pooling both classes should allow for averaging to decent resolution; we got to 8 \u00c5 this way in M but then got stuck. Perhaps another round of classification, using 12-, 13-, and 14-protofilament references, would have helped to sort out the particles at that point; but by then we had already had more success with the somewhat awkward per-filament averaging approach.   </p>"},{"location":"user_guide/examples/ribosome/","title":"Ribosome","text":""},{"location":"user_guide/examples/ribosome/#example-1-yeast-ribosomes","title":"Example 1: yeast ribosomes","text":"<p>In this example we used Warp, AreTomo3, easymode, Relion5, and M to reconstruct, denoise, segment, pick, and average the S. cerevisiae ribosome. </p> Dataset and computational resources <p>For this test we used 500 tilt series of plasma-FIB milled S. cerevisiae cells which Sebastian Tacke and colleagues at the MPI Dortmund shared with us. They are not yet available online - but you should be able to follow along with this example using other data sources as well, since easymode networks are general. We used 4 NVIDIA RTX 4090 GPUs for most processing steps.</p> <p>At the onset the data in this example consisted of just tilt series and mdocs (we did not use the gain references). <pre><code>project_root/\n\u251c\u2500\u2500 frames/        # approximately 20.000 .eer files\n\u2502   \u251c\u2500\u2500 20240731_l10t01_001_6.0_20240731_170707.eer\n\u2502   \u251c\u2500\u2500 20240731_l10t01_002_8.5_20240731_170731.eer\n\u2502   \u2514\u2500\u2500 ... \n\u2514\u2500\u2500 mdocs/         # 500 .mdoc files\n    \u251c\u2500\u2500 20240731_l10t01.mdoc\n    \u251c\u2500\u2500 20240731_l10t02.mdoc\n    \u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"user_guide/examples/ribosome/#step-1-tomogram-reconstruction","title":"Step 1: tomogram reconstruction","text":"<p><pre><code>easymode reconstruct --frames frames --mdocs mdocs --apix 1.56 --dose 2.05 --no_halfmaps\n</code></pre> We now have 500 reconstructed tomograms at 10.00 \u00c5/px in <code>warp_tiltseries/reconstruction/</code>.</p>"},{"location":"user_guide/examples/ribosome/#step-2-tomogram-denoising","title":"Step 2: tomogram denoising","text":"<p><pre><code>easymode denoise --data warp_tiltseries/reconstruction --output warp_tiltseries/reconstruction/denoised --mode direct --method n2n --gpu 0,1,2,3\n</code></pre> This produced 500 denoised tomograms in <code>warp_tiltseries/reconstruction/denoised/</code>.</p>"},{"location":"user_guide/examples/ribosome/#step-3-ribosome-segmentation","title":"Step 3: ribosome segmentation","text":"<p><pre><code>easymode segment ribosome --data warp_tiltseries/reconstruction/denoised --output segmented --tta 1 --gpu 0,1,2,3\n</code></pre> We now have 500 ribosome segmentation volumes in <code>segmented/*__ribosome.mrc</code>.</p>"},{"location":"user_guide/examples/ribosome/#step-4-ribosome-picking","title":"Step 4: ribosome picking","text":"<p><pre><code>easymode pick ribosome --data segmented --output coordinates/ribosome --binning 3 --size 2000000 --spacing 250\n</code></pre> This created 500 .star files in <code>coordinates/ribosome/</code>, one per tomogram, containing a total of 109081 ribosome coordinates.</p>"},{"location":"user_guide/examples/ribosome/#step-5-exporting-particles-with-warptools","title":"Step 5: exporting particles with WarpTools","text":"<pre><code>conda activate warp\nWarpTools ts_export_particles --input_directory coordinates/ribosome --input_pattern \"*.star\" --coords_angpix 10.0 --output_star relion/ribosome/particles.star --output_angpix 5.0 --box 96 --diameter 250 --2d --relative_output_paths\n</code></pre> <p>From here on, we followed the WarpTools tutorial for averaging apoferritin.</p>"},{"location":"user_guide/examples/ribosome/#final-result","title":"Final result","text":"<p>The final average focused on the large ribosomal subunit, after multiple rounds of refinement in M, reached an overall resolution of 3.4 \u00c5 and up to 2.6 \u00c5 in the best-resolved regions. This average was weighted per tilt and per tilt series (M EstimateWeights --resolve_items --resolve_frames), but did not require any density-based 3D classification. </p> <p></p>"},{"location":"user_guide/functions/installation/","title":"Installation","text":""},{"location":"user_guide/functions/installation/#installing-from-scratch","title":"Installing from scratch","text":"<p>The following command will create a new environment called <code>easymode</code> and install easymode and all dependencies into it.  <pre><code>conda create -n easymode python=3.9 cudatoolkit=11.8 pip -c conda-forge -y &amp;&amp; \\\nconda activate easymode &amp;&amp; \\\npip install tensorflow==2.8.0 easymode\n</code></pre> Should that fail and if you have a CUDA 11.8 module available on your cluster, try: <pre><code>conda create -n easymode python=3.9\nconda activate easymode\npip install tensorflow==2.8.0 easymode\n</code></pre></p>"},{"location":"user_guide/functions/installation/#installing-into-existing-environments","title":"Installing into existing environments","text":""},{"location":"user_guide/functions/installation/#warptools","title":"WarpTools","text":"<p>WarpTools and easymode share the same CUDA and Python versions. <pre><code>conda activate warp\npip install easymode\n</code></pre></p>"},{"location":"user_guide/functions/installation/#membrain-seg","title":"Membrain-seg","text":"<p>Membrain and easymode share the same Python version. <pre><code>conda activate membrain\npip install easymode \n</code></pre></p>"},{"location":"user_guide/functions/installation/#ais","title":"Ais","text":"<p>easymode was built on Ais, so if you have a working Ais environment, easymode should work fine in there as well. <pre><code>conda activate ais\npip install easymode\n</code></pre></p>"},{"location":"user_guide/functions/installation/#environment-settings","title":"Environment settings","text":""},{"location":"user_guide/functions/installation/#aretomo3","title":"AreTomo3","text":"<p>In case you want to use <code>easymode reconstruct</code>, you need to set the path to the AreTomo3 binary and define the required AreTomo3 environment initialization command. For example:</p> <pre><code>easymode set --aretomo3-path /public/EM/AreTomo/AreTomo3 --aretomo3-env \"module load AreTomo/3.1.0\"\n</code></pre>"},{"location":"user_guide/functions/installation/#cache-directory","title":"Cache directory","text":"<p>When using <code>easymode segment &lt;feature&gt;</code> for the first time, the required model weights will be downloaded and saved to a local cache directory (~500 MB per model). The default location is <code>~/easymode/</code>, but you can change it (for example if you want a central cache for all your users) as follows:</p> <pre><code>easymode set --cache-directory /public/easymode/cache/ \n</code></pre>"},{"location":"user_guide/functions/picking/","title":"Picking","text":"<p>easymode wraps around Ais to turn segmented volumes into coordinate .star files.</p>"},{"location":"user_guide/functions/picking/#globular-particles","title":"Globular particles","text":"<p>For approximately globular particles (such as ribosomes) use:</p> <p><pre><code>easymode pick ribosome --data segmented --output coordinates/ribosome --binning 3 --size 2000000 --spacing 250\n</code></pre> Output: <pre><code>Found 500 files with pattern /cephfs/mlast/easymode/testing/yeast/segmented/*__ribosome.mrc. Picking in blob mode.\n\n1/5 (process 19) - 0 particles in 20240802_l25t10_10.00Apx__ribosome.mrc\n1/5 (process 7) - 3 particles in 20240802_l15t04_4_10.00Apx__ribosome.mrc\n1/5 (process 14) - 194 particles in 20240802_l10t01_2_10.00Apx__ribosome.mrc\n1/5 (process 12) - 39 particles in 20240802_l15t01_3_10.00Apx__ribosome.mrc\n...\n\nfound 109081 particles in total.\n</code></pre></p> <p>Arguments: <pre><code>--output &lt;str&gt;          Directory to output per-tomogram .star files (will be created if it doesn't exist)\n--threshold &lt;float&gt;     Value to threshold segmentation volumes at (default: 128). Value range is interpreted as [0, 255], regardless of the segmentation volume data type.\n--binning &lt;int&gt;         Factor by which the segmentation volumes were binned relative to the original tomograms (default: 3). Higher value is much faster, but for small particles may introduce inaccuracies.\n--size &lt;int&gt;            Minimum volume of non-zero regions in the thresholded segmentation, in cubic \u00c5.\n--spacing &lt;int&gt;         Minimum spacing between picked coordinates, in \u00c5.\n--no_tomostar           Include this flag in order NOT to convert Warp-style tomogram names (tomogram_10.00Apx.mrc) into Warp-style tomogram starfile names (tomogram.tomostar). \n--centroid              Include this flag in order to pick the centroid of connected components, rather than maxima in the distance transform. Useful for irregularly shaped particles. Use only if individual particles are well separated in the segmentation!\n--min_particles &lt;int&gt;   Save .star files only for tomograms containing at least this number of particles.   \n</code></pre></p> <p>Note</p> <p>easymode assumes that for a feature 'feature', the segmented tomograms are named <code>tomogram__feature.mrc</code>. easymode also saves volumes using this pattern when running <code>easymode segment</code>.</p>"},{"location":"user_guide/functions/picking/#filaments","title":"Filaments","text":"<p>For picking along filaments, for instance along microtubules, we use the new filament tracing function in Ais. Simply include the <code>--filament</code> flag: <pre><code>easymode pick microtubule --data segmented --output coordiantes/microtubule --binning 3 --length 2000 --spacing 82 --separate_filaments  \n</code></pre></p> <pre><code>Found 1266 files with pattern /cephfs/mlast/easymode/testing/human/segmented/*__microtubule.mrc. Picking in filament mode.\n\n1/11 (process 89) - 40 particles in 1 filaments in 250715_l1p3_10.00Apx__microtubule.mrc\n1/11 (process 46) - 0 particles in 0 filaments in l14p5_5_10.00Apx__microtubule.mrc\n1/12 (process 24) - 102 particles in 6 filaments in 250106_l6p1_6_10.00Apx__microtubule.mrc\n...\n\nfound 28381 particles in total. that's 232.7 um of microtubule :)\n</code></pre> <p>Tip</p> <p>Use the flag <code>--separate_filaments</code> to save .star files per filament, rather than per tomogram. This is useful if you want to do per-filament averaging, which can be used to assign polarity or count protofilament numbers.</p> <p>Note</p> <p>Segmentation is computationally expensive part, but turning segmentations into coordinates is quite cheap. The examples above, picking in 500 and 1266 tomograms respectively, both completed in less than a minute. This is a typical speed if the <code>--binning</code> value is set to 3 or higher and the filesystem can keep up with all the loading. </p>"},{"location":"user_guide/functions/preprocessing/","title":"Preprocessing","text":"<p>Although the core of easymode is really just about feature detection, we've included a couple of tools to facilitate cryoET data preprocessing. These are built on Warp and AreTomo3.</p>"},{"location":"user_guide/functions/preprocessing/#fully-automated-tomogram-reconstruction","title":"Fully automated tomogram reconstruction","text":"<p>Use <code>easymode reconstruct</code> to convert input frames and mdoc files into tomograms fully automatically. This command simply wraps around Warp and AreTomo3, so all credit goes to those authors! Requires setting up Warp and AreTomo3 as described on the installation page.</p> <pre><code>easymode reconstruct --frames frames/ --mdocs mdocs/ --apix 1.56 --dose 3.20\n</code></pre> <p>Optional arguments: <pre><code>--thickness &lt;int&gt;         Thickness of the tomogram in \u00c5 (default: 3000)\n--extension &lt;str&gt;         File extension of the input frames (default: auto-detected)\n--tomo_apix &lt;float&gt;       Output pixel size in \u00c5 (default is 10 \u00c5/px).\n--shape &lt;int&gt;x&lt;int&gt;       Size (in pixels) of the tilt images (default: auto-detected)\n--no_halfmaps             Include this flag in order NOT to generate even/odd frame and volume splits\n</code></pre></p> <p>Tip: direct denoising</p> <p>If you don't need perfect denoising performance and good is good enough, you can use a pretrained denoiser and save time &amp; memory by skipping the generation of halfmaps with <code>--no_halfmaps</code>. More about this in the Denoising section.</p>"},{"location":"user_guide/functions/preprocessing/#denoising","title":"Denoising","text":"<p>In cases where you don't have access to raw frames, or you want to save memory, or want to save time, you can denoise your full tomograms directly using <code>easymode denoise</code>, our pretrained noise2noise model. </p> <pre><code>easymode denoise --data warp_tiltseries/reconstruction --output warp_tiltseries/reconstruction/denoised --mode direct --method n2n --gpu 0,1,2,3\n</code></pre> <p>Optional arguments: <pre><code>--mode {'direct', 'splits'}     Use 'direct' mode to denoise full tomograms, or 'splits' to denoise and combine independent even and odd tomogram splits.\n--tta &lt;int&gt;                     Test-time augmentation factor (default: 1). Probably superflous for denoising; when set to &gt;1, the model will denoise multiple augmented versions of the input and average the results.\n--iter &lt;int&gt;                    Number of denoising iterations to perform (default: 1). Only valid in 'direct' mode. A direct denoiser can be re-applied to its own output, to enhance contrast further - at the risk of introducing many artifacts.\n--overwrite                     If used, if output tomograms already exist in --output, they will be overwritten.\n</code></pre></p> <p>Note</p> <p>For optimal denoising , it is probably always best to train a new network on your own data. But for general segmentation and picking purposes, the easymode general denoiser does the job. </p>"},{"location":"user_guide/functions/preprocessing/#direct-versus-split-denoising","title":"Direct versus split denoising","text":"<p>We currently offer one denoising method (noise2noise), and two denoising modes: direct and splits. In 'splits' mode, we denoise in the usual way: using a network that was trained on independent data splits (e.g., even and odd volumes), running inference on the even and odd volume and averaging the results. This is the statistically sound and superior method, but generating and processing the independent splits can cost a lot of time and memory. Plus, it requires access to splittable data, ideally raw frame stacks, which are not always available (although you can always split on the tilt angles)</p> <p>In 'direct' mode, we use a network that was trained in two steps. First, we trained in the typical even -&gt; odd fashion. We then applied the resulting network to denoise all training subtomograms, and prepared a new training set using full subtomograms (i.e. the even + odd splits) as the input, and the denoised subtomogram as the output. The resulting model can be applied to full tomograms directly, and approximates the output that even/odd denoising achieves relatively well. It is faster and requires less</p>"},{"location":"user_guide/functions/segmentation/","title":"Segmentation","text":"<p>Segmentation is the core of easymode. To list features for which pretrained models are available, run:</p> <pre><code>easymode list\n</code></pre> <p>Example output: <pre><code>easymode can currently segment the following features:\n    &gt; ribosome\n    &gt; microtubule\n    &gt; mitochondrion\n    &gt; npc\n    &gt; tric\n    &gt; actin\n    &gt; mitochondrial_granule\n    &gt; cytoplasmic_granule\n    &gt; nuclear_envelope\n    &gt; vault\n</code></pre></p> <p>To segment any of these features in your tomograms, use the <code>easymode segment &lt;feature&gt;</code> command. For example:</p> <pre><code>easymode segment ribosome --data warp_tiltseries/reconstruction --output segmented/ --gpu 0,1,2,3,4,5,6,7\n</code></pre> <p>Optional arguments: <pre><code>--tta &lt;int&gt;             Test-time augmentation factor (default: 4). The model will segment multiple augmented versions of the input and average the results.\n--overwrite             If used, if output tomograms already exist in --output, they will be overwritten.\n--format                Output format for the segmented volumes. Choices are 'float32', 'uint16', or 'int8' (default).\n</code></pre></p> <p>Note</p> <p>easymode uses almost exactly the same network architecture as Membrain. If your hardware can handle Membrain, it should also work for easymode.</p> <p>Tip</p> <p>If accuracy is not super important, set <code>--tta 1</code> to speed up segmentation significantly. This can be useful when you're just exploring the data and only want to roughly estimate tomogram contents.</p> <p>Note</p> <p>You can run multiple processes simultaneously on the same data and for the same feature, for example if you have some GPUs on cluster node A and some more on cluster node B. Whenever a thread starts processing a tomogram, it creates a provisional output file that prevents other threads from processing that same tomogram. In some cases, when you abort a process, a number of preliminary output files may not be deleted properly. In that case, simply delete those files manually before restarting the segmentation.</p>"}]}